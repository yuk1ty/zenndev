---
title: "変数宣言、関数宣言"
---

プログラムを書く際の最も基本的なポイントである、変数宣言と関数宣言をマスターしましょう。

## 変数宣言のポイント

Java でいうところの下記をやりたい際に、どうしたらよいかという話をこれからしていきます。

```java
public class Main {
		public static void main(String... args) {
				int x = 1;
				x = 2;
				System.out.println(x);
		}
}
```

### 変数宣言は let を用いる

まず、変数宣言は `let` というキーワードを用いて行うことができます。

さっそくプログラムを見ていきます。`a` という変数に `1`、`b` という変数に `2` という値をそれぞれ、`a`、`b` という変数に**束縛**します。また、`a` と `b` を足し算して、その結果の値を `answer` という変数に同様に束縛します。答えは 3 です。

:::message
値を変数に束縛するという単語は耳慣れないかもしれません。Rust の文脈ではだいたいの場合、変数に値を代入することを、変数に値を束縛するという言い方をされます。これを変数束縛 (variable binding) と呼びます。コンパイルエラーメッセージでもこの binding という単語が頻繁に登場します。Rust では、「値」は値の所有者である「変数」に「束縛」されるという言い方をします。が、今回はハンズオンなので、値を変数に**代入する**という言い方を以降はするようにします。
:::

```rust
fn main() {
    let a = 1;
    let b = 2;
    let answer = a + b;
    println!("{}", answer); // 3
}
```

### 変数はデフォルトはイミュータブル

さて、ここでよくあるプログラムのように、宣言された変数に対して値を 1 回代入し、さらにもう一度その変数に対して新しい値を代入し直すというコードを書いてみましょう。

```rust
fn main() {
    let x = 1;
    x = 2; // compile error
    println!("{}", x);
}
```

すると Rust のコンパイラはエラーを返します。

```
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:3:5
  |
2 |     let x = 1;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     x = 2; // compile error
  |     ^^^^^ cannot assign twice to immutable variable
```

コンパイラが教えてくれているエラーメッセージで重要なものは下記です。

- cannot assign twice to immutable variable `x`
  - イミュータブルな変数 `x` に 2 度代入をすることはできない。
- help: make this binding mutable: `mut x`
  - この束縛をミュータブルにしよう: `mut x`

このエラーが出た理由は、**Rust の変数宣言はデフォルトでイミュータブルだから**す。イミュータブルとはどういうことかというと、文脈によっていくつか意味が出てきますが、

- 作成した後はその中身を変更できない。
  - 変数ならば、作成後は再代入を通じた値の書き換えをできない。
  - これから登場する構造体であれば、自身のもつデータの内容は、一度生成したあとは書き換えできない。

といった意味合いになるでしょう。

イミュータブルなプログラミングスタイルには、たとえば下記のようなメリット／デメリットがあります。

- メリット: 1 度変数（or データ）を作成した後に中身を書き換えたくなった際には、基本的にはその変数を再作成する必要があるので、変数のスコープが短くなりやすい。
- メリット: 大規模なプログラムになった際に、設計者のよきしない不意な書き換えが起こりにくい。
- メリット: 並列処理や並行処理時に不用意な書き換えが原因となったバグを仕込みにくい。
- デメリット: 不用意なコピーが発生しやすくなり、適切に制御できないと用意にパフォーマンスネックになる。

話がそれましたが、Rust ではイミュータブル・ミュータブルの切り替えをすばやくできる手段を提供しています。`let` の後ろに `mut` とつけるだけです。

```rust
fn main() {
    let mut x = 1;
    x = 2; // コンパイルエラーは消える
    println!("{}", x); // 2 が表示される
}
```

### 型推論

Rust は静的型付き言語だと述べましたが、ここまで一度も型を書くシーンに出くわしませんでした。これはなぜでしょうか？たとえば下記のプログラムには、型に関する情報が一切出てきていません。Rust は動的型付き言語なのでしょうか？

```rust
fn main() {
    let mut x = 1;
    x = 2;
    println!("{}", x);
}
```

実は、裏側では型推論という仕組みが走っています。型推論があると、プログラマは型を逐一書く必要がありません。たとえば Java だと、次のように都度変数の型を書く必要があったものが[^1]、Rust では必要ありません。

```java
public class Main {
		public static void main(String... args) {
				int x = 1;
				x = 2;
				System.out.println(x);
		}
}
```

Rust の型推論は非常に賢いので、ほとんど型を書く場面に出くわすことはありません。後ほど紹介する関数の返り値に必須なのと、あとは、コンビネータ (`filter` や `map` などの便利関数) を用いて `Vec` などを生成する際に使用する `collect` という関数などに必要になるくらいです。基本的には Rust のコンパイラは変数を正しく推論してくれます。

もし、明示的に型を推論したくなった場合は、下記のように変数の横に `:{型名}` と書くと型を明示的に書くことができます。

```rust
fn main() {
    let mut x: i32 = 1;
    x = 2;
    println!("{}", x);
}
```

今回のハンズオンでは詳しく解説しませんが、Rust で使用できるプリミティブなデータ型については次のドキュメントにまとまっています。

https://doc.rust-jp.rs/book-ja/ch03-02-data-types.html

[^1]: もっとも、最近の Java では型推論を使用できる記法 `var` が入りましたね。

## 関数宣言のポイント

関数宣言は `fn` というキーワードを用いて行うことができます。たとえば、自身がバリウム検査の対象かどうかを判定するプログラムは次のように書くことができます。

Rust では次のように書きます。

```rust
fn should_test_barium(age: i32) -> bool {
    println!("あなたは {} 歳です", age);
    age > 35
}

fn main() {
    let i_should_test_barium = should_test_barium(29);
    println!("{}", i_should_test_barium); // false。やったぜ。
}
```

ポイントは

- Rust では関数は第一級として扱える。
- 関数内での `return` 時には、`return` と書く必要はないが、セミコロンをなしにする必要がある。

です。実際、最後の `age > 35` にセミコロンをつけると、その部分は文になるので値を返さないユニット型として判定され、コンパイルエラーとなってしまいます。

余談ですが Rust では関数は第一級なので、`class` などのオブジェクト[^2]で囲ってから使用する必要はありません。

[^2]: Rust には `class` 構文はありませんが、Java 等との比較のために出しています。

## 演習

2 つの入力を受け取って、大きい数値を返す関数を用意してみましょう。最後に、`main` 関数内でその関数を呼び出してみて、実行するところまで書いてみましょう。関数のシグネチャは下記のようになるものとします。

```rust
fn is_left_bigger_than_right(left: i32, right: i32) -> bool
```

:::details 答え

```rust
fn is_left_bigger_than_right(left: i32, right: i32) -> bool {
    left > right
}

fn main() {
    let left = 1;
    let right = 2;
    println!("{}", is_left_bigger_than_right(left, right)); // false
}
```

:::
